// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodel

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Track is an object representing the database table.
type Track struct {
	TrackID         int       `boil:"track_id" json:"track_id" toml:"track_id" yaml:"track_id"`
	Title           string    `boil:"title" json:"title" toml:"title" yaml:"title"`
	Artist          string    `boil:"artist" json:"artist" toml:"artist" yaml:"artist"`
	Composer        string    `boil:"composer" json:"composer" toml:"composer" yaml:"composer"`
	TrackNo         int       `boil:"track_no" json:"track_no" toml:"track_no" yaml:"track_no"`
	Lyrics          string    `boil:"lyrics" json:"lyrics" toml:"lyrics" yaml:"lyrics"`
	Comment         string    `boil:"comment" json:"comment" toml:"comment" yaml:"comment"`
	Year            int       `boil:"year" json:"year" toml:"year" yaml:"year"`
	FilePath        string    `boil:"file_path" json:"file_path" toml:"file_path" yaml:"file_path"`
	FilePathMD5Hash string    `boil:"file_path_md5_hash" json:"file_path_md5_hash" toml:"file_path_md5_hash" yaml:"file_path_md5_hash"`
	FileMD5Hash     string    `boil:"file_md5_hash" json:"file_md5_hash" toml:"file_md5_hash" yaml:"file_md5_hash"`
	Format          string    `boil:"format" json:"format" toml:"format" yaml:"format"`
	FileType        string    `boil:"file_type" json:"file_type" toml:"file_type" yaml:"file_type"`
	AlbumArtistID   int       `boil:"album_artist_id" json:"album_artist_id" toml:"album_artist_id" yaml:"album_artist_id"`
	AlbumID         int       `boil:"album_id" json:"album_id" toml:"album_id" yaml:"album_id"`
	GenreID         int       `boil:"genre_id" json:"genre_id" toml:"genre_id" yaml:"genre_id"`
	CreatedAt       time.Time `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt       time.Time `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`

	R *trackR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L trackL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var TrackColumns = struct {
	TrackID         string
	Title           string
	Artist          string
	Composer        string
	TrackNo         string
	Lyrics          string
	Comment         string
	Year            string
	FilePath        string
	FilePathMD5Hash string
	FileMD5Hash     string
	Format          string
	FileType        string
	AlbumArtistID   string
	AlbumID         string
	GenreID         string
	CreatedAt       string
	UpdatedAt       string
}{
	TrackID:         "track_id",
	Title:           "title",
	Artist:          "artist",
	Composer:        "composer",
	TrackNo:         "track_no",
	Lyrics:          "lyrics",
	Comment:         "comment",
	Year:            "year",
	FilePath:        "file_path",
	FilePathMD5Hash: "file_path_md5_hash",
	FileMD5Hash:     "file_md5_hash",
	Format:          "format",
	FileType:        "file_type",
	AlbumArtistID:   "album_artist_id",
	AlbumID:         "album_id",
	GenreID:         "genre_id",
	CreatedAt:       "created_at",
	UpdatedAt:       "updated_at",
}

var TrackTableColumns = struct {
	TrackID         string
	Title           string
	Artist          string
	Composer        string
	TrackNo         string
	Lyrics          string
	Comment         string
	Year            string
	FilePath        string
	FilePathMD5Hash string
	FileMD5Hash     string
	Format          string
	FileType        string
	AlbumArtistID   string
	AlbumID         string
	GenreID         string
	CreatedAt       string
	UpdatedAt       string
}{
	TrackID:         "tracks.track_id",
	Title:           "tracks.title",
	Artist:          "tracks.artist",
	Composer:        "tracks.composer",
	TrackNo:         "tracks.track_no",
	Lyrics:          "tracks.lyrics",
	Comment:         "tracks.comment",
	Year:            "tracks.year",
	FilePath:        "tracks.file_path",
	FilePathMD5Hash: "tracks.file_path_md5_hash",
	FileMD5Hash:     "tracks.file_md5_hash",
	Format:          "tracks.format",
	FileType:        "tracks.file_type",
	AlbumArtistID:   "tracks.album_artist_id",
	AlbumID:         "tracks.album_id",
	GenreID:         "tracks.genre_id",
	CreatedAt:       "tracks.created_at",
	UpdatedAt:       "tracks.updated_at",
}

// Generated where

var TrackWhere = struct {
	TrackID         whereHelperint
	Title           whereHelperstring
	Artist          whereHelperstring
	Composer        whereHelperstring
	TrackNo         whereHelperint
	Lyrics          whereHelperstring
	Comment         whereHelperstring
	Year            whereHelperint
	FilePath        whereHelperstring
	FilePathMD5Hash whereHelperstring
	FileMD5Hash     whereHelperstring
	Format          whereHelperstring
	FileType        whereHelperstring
	AlbumArtistID   whereHelperint
	AlbumID         whereHelperint
	GenreID         whereHelperint
	CreatedAt       whereHelpertime_Time
	UpdatedAt       whereHelpertime_Time
}{
	TrackID:         whereHelperint{field: "`tracks`.`track_id`"},
	Title:           whereHelperstring{field: "`tracks`.`title`"},
	Artist:          whereHelperstring{field: "`tracks`.`artist`"},
	Composer:        whereHelperstring{field: "`tracks`.`composer`"},
	TrackNo:         whereHelperint{field: "`tracks`.`track_no`"},
	Lyrics:          whereHelperstring{field: "`tracks`.`lyrics`"},
	Comment:         whereHelperstring{field: "`tracks`.`comment`"},
	Year:            whereHelperint{field: "`tracks`.`year`"},
	FilePath:        whereHelperstring{field: "`tracks`.`file_path`"},
	FilePathMD5Hash: whereHelperstring{field: "`tracks`.`file_path_md5_hash`"},
	FileMD5Hash:     whereHelperstring{field: "`tracks`.`file_md5_hash`"},
	Format:          whereHelperstring{field: "`tracks`.`format`"},
	FileType:        whereHelperstring{field: "`tracks`.`file_type`"},
	AlbumArtistID:   whereHelperint{field: "`tracks`.`album_artist_id`"},
	AlbumID:         whereHelperint{field: "`tracks`.`album_id`"},
	GenreID:         whereHelperint{field: "`tracks`.`genre_id`"},
	CreatedAt:       whereHelpertime_Time{field: "`tracks`.`created_at`"},
	UpdatedAt:       whereHelpertime_Time{field: "`tracks`.`updated_at`"},
}

// TrackRels is where relationship names are stored.
var TrackRels = struct {
	AlbumArtist string
	Album       string
	Genre       string
}{
	AlbumArtist: "AlbumArtist",
	Album:       "Album",
	Genre:       "Genre",
}

// trackR is where relationships are stored.
type trackR struct {
	AlbumArtist *AlbumArtist `boil:"AlbumArtist" json:"AlbumArtist" toml:"AlbumArtist" yaml:"AlbumArtist"`
	Album       *Album       `boil:"Album" json:"Album" toml:"Album" yaml:"Album"`
	Genre       *Genre       `boil:"Genre" json:"Genre" toml:"Genre" yaml:"Genre"`
}

// NewStruct creates a new relationship struct
func (*trackR) NewStruct() *trackR {
	return &trackR{}
}

// trackL is where Load methods for each relationship are stored.
type trackL struct{}

var (
	trackAllColumns            = []string{"track_id", "title", "artist", "composer", "track_no", "lyrics", "comment", "year", "file_path", "file_path_md5_hash", "file_md5_hash", "format", "file_type", "album_artist_id", "album_id", "genre_id", "created_at", "updated_at"}
	trackColumnsWithoutDefault = []string{"title", "artist", "composer", "track_no", "lyrics", "comment", "year", "file_path", "file_path_md5_hash", "file_md5_hash", "format", "file_type", "album_artist_id", "album_id", "genre_id", "created_at", "updated_at"}
	trackColumnsWithDefault    = []string{"track_id"}
	trackPrimaryKeyColumns     = []string{"track_id"}
)

type (
	// TrackSlice is an alias for a slice of pointers to Track.
	// This should almost always be used instead of []Track.
	TrackSlice []*Track
	// TrackHook is the signature for custom Track hook methods
	TrackHook func(context.Context, boil.ContextExecutor, *Track) error

	trackQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	trackType                 = reflect.TypeOf(&Track{})
	trackMapping              = queries.MakeStructMapping(trackType)
	trackPrimaryKeyMapping, _ = queries.BindMapping(trackType, trackMapping, trackPrimaryKeyColumns)
	trackInsertCacheMut       sync.RWMutex
	trackInsertCache          = make(map[string]insertCache)
	trackUpdateCacheMut       sync.RWMutex
	trackUpdateCache          = make(map[string]updateCache)
	trackUpsertCacheMut       sync.RWMutex
	trackUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var trackBeforeInsertHooks []TrackHook
var trackBeforeUpdateHooks []TrackHook
var trackBeforeDeleteHooks []TrackHook
var trackBeforeUpsertHooks []TrackHook

var trackAfterInsertHooks []TrackHook
var trackAfterSelectHooks []TrackHook
var trackAfterUpdateHooks []TrackHook
var trackAfterDeleteHooks []TrackHook
var trackAfterUpsertHooks []TrackHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Track) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range trackBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Track) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range trackBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Track) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range trackBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Track) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range trackBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Track) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range trackAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Track) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range trackAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Track) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range trackAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Track) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range trackAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Track) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range trackAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddTrackHook registers your hook function for all future operations.
func AddTrackHook(hookPoint boil.HookPoint, trackHook TrackHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		trackBeforeInsertHooks = append(trackBeforeInsertHooks, trackHook)
	case boil.BeforeUpdateHook:
		trackBeforeUpdateHooks = append(trackBeforeUpdateHooks, trackHook)
	case boil.BeforeDeleteHook:
		trackBeforeDeleteHooks = append(trackBeforeDeleteHooks, trackHook)
	case boil.BeforeUpsertHook:
		trackBeforeUpsertHooks = append(trackBeforeUpsertHooks, trackHook)
	case boil.AfterInsertHook:
		trackAfterInsertHooks = append(trackAfterInsertHooks, trackHook)
	case boil.AfterSelectHook:
		trackAfterSelectHooks = append(trackAfterSelectHooks, trackHook)
	case boil.AfterUpdateHook:
		trackAfterUpdateHooks = append(trackAfterUpdateHooks, trackHook)
	case boil.AfterDeleteHook:
		trackAfterDeleteHooks = append(trackAfterDeleteHooks, trackHook)
	case boil.AfterUpsertHook:
		trackAfterUpsertHooks = append(trackAfterUpsertHooks, trackHook)
	}
}

// One returns a single track record from the query.
func (q trackQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Track, error) {
	o := &Track{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodel: failed to execute a one query for tracks")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Track records from the query.
func (q trackQuery) All(ctx context.Context, exec boil.ContextExecutor) (TrackSlice, error) {
	var o []*Track

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dbmodel: failed to assign all query results to Track slice")
	}

	if len(trackAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Track records in the query.
func (q trackQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodel: failed to count tracks rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q trackQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dbmodel: failed to check if tracks exists")
	}

	return count > 0, nil
}

// AlbumArtist pointed to by the foreign key.
func (o *Track) AlbumArtist(mods ...qm.QueryMod) albumArtistQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`album_artist_id` = ?", o.AlbumArtistID),
	}

	queryMods = append(queryMods, mods...)

	query := AlbumArtists(queryMods...)
	queries.SetFrom(query.Query, "`album_artists`")

	return query
}

// Album pointed to by the foreign key.
func (o *Track) Album(mods ...qm.QueryMod) albumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`album_id` = ?", o.AlbumID),
	}

	queryMods = append(queryMods, mods...)

	query := Albums(queryMods...)
	queries.SetFrom(query.Query, "`album`")

	return query
}

// Genre pointed to by the foreign key.
func (o *Track) Genre(mods ...qm.QueryMod) genreQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`genre_id` = ?", o.GenreID),
	}

	queryMods = append(queryMods, mods...)

	query := Genres(queryMods...)
	queries.SetFrom(query.Query, "`genres`")

	return query
}

// LoadAlbumArtist allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (trackL) LoadAlbumArtist(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTrack interface{}, mods queries.Applicator) error {
	var slice []*Track
	var object *Track

	if singular {
		object = maybeTrack.(*Track)
	} else {
		slice = *maybeTrack.(*[]*Track)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &trackR{}
		}
		args = append(args, object.AlbumArtistID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &trackR{}
			}

			for _, a := range args {
				if a == obj.AlbumArtistID {
					continue Outer
				}
			}

			args = append(args, obj.AlbumArtistID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`album_artists`),
		qm.WhereIn(`album_artists.album_artist_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load AlbumArtist")
	}

	var resultSlice []*AlbumArtist
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice AlbumArtist")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for album_artists")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for album_artists")
	}

	if len(trackAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.AlbumArtist = foreign
		if foreign.R == nil {
			foreign.R = &albumArtistR{}
		}
		foreign.R.Tracks = append(foreign.R.Tracks, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.AlbumArtistID == foreign.AlbumArtistID {
				local.R.AlbumArtist = foreign
				if foreign.R == nil {
					foreign.R = &albumArtistR{}
				}
				foreign.R.Tracks = append(foreign.R.Tracks, local)
				break
			}
		}
	}

	return nil
}

// LoadAlbum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (trackL) LoadAlbum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTrack interface{}, mods queries.Applicator) error {
	var slice []*Track
	var object *Track

	if singular {
		object = maybeTrack.(*Track)
	} else {
		slice = *maybeTrack.(*[]*Track)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &trackR{}
		}
		args = append(args, object.AlbumID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &trackR{}
			}

			for _, a := range args {
				if a == obj.AlbumID {
					continue Outer
				}
			}

			args = append(args, obj.AlbumID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`album`),
		qm.WhereIn(`album.album_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Album")
	}

	var resultSlice []*Album
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Album")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for album")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for album")
	}

	if len(trackAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Album = foreign
		if foreign.R == nil {
			foreign.R = &albumR{}
		}
		foreign.R.Tracks = append(foreign.R.Tracks, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.AlbumID == foreign.AlbumID {
				local.R.Album = foreign
				if foreign.R == nil {
					foreign.R = &albumR{}
				}
				foreign.R.Tracks = append(foreign.R.Tracks, local)
				break
			}
		}
	}

	return nil
}

// LoadGenre allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (trackL) LoadGenre(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTrack interface{}, mods queries.Applicator) error {
	var slice []*Track
	var object *Track

	if singular {
		object = maybeTrack.(*Track)
	} else {
		slice = *maybeTrack.(*[]*Track)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &trackR{}
		}
		args = append(args, object.GenreID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &trackR{}
			}

			for _, a := range args {
				if a == obj.GenreID {
					continue Outer
				}
			}

			args = append(args, obj.GenreID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`genres`),
		qm.WhereIn(`genres.genre_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Genre")
	}

	var resultSlice []*Genre
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Genre")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for genres")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for genres")
	}

	if len(trackAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Genre = foreign
		if foreign.R == nil {
			foreign.R = &genreR{}
		}
		foreign.R.Tracks = append(foreign.R.Tracks, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.GenreID == foreign.GenreID {
				local.R.Genre = foreign
				if foreign.R == nil {
					foreign.R = &genreR{}
				}
				foreign.R.Tracks = append(foreign.R.Tracks, local)
				break
			}
		}
	}

	return nil
}

// SetAlbumArtist of the track to the related item.
// Sets o.R.AlbumArtist to related.
// Adds o to related.R.Tracks.
func (o *Track) SetAlbumArtist(ctx context.Context, exec boil.ContextExecutor, insert bool, related *AlbumArtist) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `tracks` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"album_artist_id"}),
		strmangle.WhereClause("`", "`", 0, trackPrimaryKeyColumns),
	)
	values := []interface{}{related.AlbumArtistID, o.TrackID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.AlbumArtistID = related.AlbumArtistID
	if o.R == nil {
		o.R = &trackR{
			AlbumArtist: related,
		}
	} else {
		o.R.AlbumArtist = related
	}

	if related.R == nil {
		related.R = &albumArtistR{
			Tracks: TrackSlice{o},
		}
	} else {
		related.R.Tracks = append(related.R.Tracks, o)
	}

	return nil
}

// SetAlbum of the track to the related item.
// Sets o.R.Album to related.
// Adds o to related.R.Tracks.
func (o *Track) SetAlbum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Album) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `tracks` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"album_id"}),
		strmangle.WhereClause("`", "`", 0, trackPrimaryKeyColumns),
	)
	values := []interface{}{related.AlbumID, o.TrackID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.AlbumID = related.AlbumID
	if o.R == nil {
		o.R = &trackR{
			Album: related,
		}
	} else {
		o.R.Album = related
	}

	if related.R == nil {
		related.R = &albumR{
			Tracks: TrackSlice{o},
		}
	} else {
		related.R.Tracks = append(related.R.Tracks, o)
	}

	return nil
}

// SetGenre of the track to the related item.
// Sets o.R.Genre to related.
// Adds o to related.R.Tracks.
func (o *Track) SetGenre(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Genre) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `tracks` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"genre_id"}),
		strmangle.WhereClause("`", "`", 0, trackPrimaryKeyColumns),
	)
	values := []interface{}{related.GenreID, o.TrackID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.GenreID = related.GenreID
	if o.R == nil {
		o.R = &trackR{
			Genre: related,
		}
	} else {
		o.R.Genre = related
	}

	if related.R == nil {
		related.R = &genreR{
			Tracks: TrackSlice{o},
		}
	} else {
		related.R.Tracks = append(related.R.Tracks, o)
	}

	return nil
}

// Tracks retrieves all the records using an executor.
func Tracks(mods ...qm.QueryMod) trackQuery {
	mods = append(mods, qm.From("`tracks`"))
	return trackQuery{NewQuery(mods...)}
}

// FindTrack retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindTrack(ctx context.Context, exec boil.ContextExecutor, trackID int, selectCols ...string) (*Track, error) {
	trackObj := &Track{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `tracks` where `track_id`=?", sel,
	)

	q := queries.Raw(query, trackID)

	err := q.Bind(ctx, exec, trackObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodel: unable to select from tracks")
	}

	if err = trackObj.doAfterSelectHooks(ctx, exec); err != nil {
		return trackObj, err
	}

	return trackObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Track) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodel: no tracks provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(trackColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	trackInsertCacheMut.RLock()
	cache, cached := trackInsertCache[key]
	trackInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			trackAllColumns,
			trackColumnsWithDefault,
			trackColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(trackType, trackMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(trackType, trackMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `tracks` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `tracks` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `tracks` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, trackPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "dbmodel: unable to insert into tracks")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.TrackID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == trackMapping["track_id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.TrackID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "dbmodel: unable to populate default values for tracks")
	}

CacheNoHooks:
	if !cached {
		trackInsertCacheMut.Lock()
		trackInsertCache[key] = cache
		trackInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Track.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Track) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	trackUpdateCacheMut.RLock()
	cache, cached := trackUpdateCache[key]
	trackUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			trackAllColumns,
			trackPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("dbmodel: unable to update tracks, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `tracks` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, trackPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(trackType, trackMapping, append(wl, trackPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodel: unable to update tracks row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodel: failed to get rows affected by update for tracks")
	}

	if !cached {
		trackUpdateCacheMut.Lock()
		trackUpdateCache[key] = cache
		trackUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q trackQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodel: unable to update all for tracks")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodel: unable to retrieve rows affected for tracks")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o TrackSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dbmodel: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), trackPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `tracks` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, trackPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodel: unable to update all in track slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodel: unable to retrieve rows affected all in update all track")
	}
	return rowsAff, nil
}

var mySQLTrackUniqueColumns = []string{
	"track_id",
	"file_path_md5_hash",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Track) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodel: no tracks provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(trackColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLTrackUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	trackUpsertCacheMut.RLock()
	cache, cached := trackUpsertCache[key]
	trackUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			trackAllColumns,
			trackColumnsWithDefault,
			trackColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			trackAllColumns,
			trackPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("dbmodel: unable to upsert tracks, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`tracks`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `tracks` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(trackType, trackMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(trackType, trackMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "dbmodel: unable to upsert for tracks")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.TrackID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == trackMapping["track_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(trackType, trackMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "dbmodel: unable to retrieve unique values for tracks")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "dbmodel: unable to populate default values for tracks")
	}

CacheNoHooks:
	if !cached {
		trackUpsertCacheMut.Lock()
		trackUpsertCache[key] = cache
		trackUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Track record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Track) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("dbmodel: no Track provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), trackPrimaryKeyMapping)
	sql := "DELETE FROM `tracks` WHERE `track_id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodel: unable to delete from tracks")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodel: failed to get rows affected by delete for tracks")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q trackQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dbmodel: no trackQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodel: unable to delete all from tracks")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodel: failed to get rows affected by deleteall for tracks")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o TrackSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(trackBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), trackPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `tracks` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, trackPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodel: unable to delete all from track slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodel: failed to get rows affected by deleteall for tracks")
	}

	if len(trackAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Track) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindTrack(ctx, exec, o.TrackID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *TrackSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := TrackSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), trackPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `tracks`.* FROM `tracks` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, trackPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dbmodel: unable to reload all in TrackSlice")
	}

	*o = slice

	return nil
}

// TrackExists checks if the Track row exists.
func TrackExists(ctx context.Context, exec boil.ContextExecutor, trackID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `tracks` where `track_id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, trackID)
	}
	row := exec.QueryRowContext(ctx, sql, trackID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dbmodel: unable to check if tracks exists")
	}

	return exists, nil
}
